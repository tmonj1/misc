## 0. サマリのサマリ

* 従来型のSSOやSAMLはWebブラウザを対象としており、ネイティブクライアントでは使えないのでOIDCが普及した
* OIDCはWebブラウザだけでなくネイティブクライアント（とAPIサーバ）も考慮された設計になっている。
* 複数のフローがあるが、主に使うのは「認可コードフロー+PKCE」（WebブラウザとネイティブクライアントはこれでOK）。公開クライアントは動的登録する。
* 認可コードフローが使えないときはその他のフローを使う。ただし、インプリシットフローとパスワードフローは（セキュリティ的に弱いので）使わない。

## 1. OAuth 2.0の基本的な考え方

OAuthは以下のような問題を解決するために考案された。

* ユーザー(=リソースオーナー)はクライアントからリソースサーバ上の自分のリソースへのアクセスを許可したい
* ただし、クリデンシャルはクライアントに開示したくない
* ユーザがその場にいない状況でもクライアントからリソースサーバにアクセスできるようにしたい
  * 毎回IDとパスワードをユーザが入力するようなことはしたくない

OAuthは上記の問題を、リソース初回アクセス時にユーザーの明示的な同意を経て (=いわゆるTOFU: Trusted On First Time)認可サーバがアクセストークンを発行する、という形で解決した。このアクセストークン発行までのフローを定義したものがOAuth 2.0。

フローにはいくつか種類があるが、代表的なのは認可コードフロー。認可コードフローでは、クライアントは保護リソースへのアクセスが必要になると、ユーザを認可サーバにリダイレクトし、認可コードを取得する。次に直接認可サーバにリクエストを実行してアクセストークンを取得する。これで保護されたリソースにアクセスできるようになる。

ユーザが認可サーバにリダイレクトされたときに認証サーバとユーザとの間で認証が実行されるが、ここの認証方法は何でも良い（OAuth 2.0の仕様の対象外）。また、クライアントはアクセストークンの中身は感知しない。

OAuth 2.0では、セキュリティ上の決定をセキュリティ管理組織側ではなくユーザがおこなうという特徴がある。

## 2. OAuth 2.0 のプロトコル概要

詳細は[RFC6749](https://tools.ietf.org/html/rfc6749)参照するとよい。

OAuth 2.0は大きく分けると**認可リクエスト**と**トークンリクエスト**の2つに分かれている。

|種類|エンドポイント|説明|
|:--|:--|:--|
|認可リクエスト|認可エンドポイント|クライアントから認可サーバへのリダイレクト|
|トークンリクエスト|トークンエンドポイント|クライアントから認可サーバへのPOSTコール|

* 認可リクエスト時、認可サーバはユーザ（＝リソース所有者）を認証する
* トークンリクエスト時、認可サーバはクライアントを認証する

OAuth 2.0の認可フローにはいくつかの種類がある。ただし後で説明するとおり、現在はいくつかが非推奨になっており、使うべきは認可コードフローとクライアントクリデンシャルフロー、それに後から追加されたデバイスフローだけ。

|認可フロー|response_type|grant_type|説明|
|:--|:--|:--|:--|
|認可コードフロー|code|authorization_code|最初に認可コードを取得し、次に認可コードをアクセストークンに交換する|
|~~インプリシットフロー~~|~~token~~|-|~~認可エンドポイントから直接アクセストークンを発行するフロー~~|
|クライアントクリデンシャルフロー|-|client_credentials|クライアントシークレットを指定|
|アサーションフロー|-|urn:ietf:params:oauth:grant-type:jwt-bearer|JWTを指定|
|~~パスワードフロー~~|-|~~password~~|~~パスワードを指定~~|

* インプリシットフローとパスワードフローは非推奨になった
* 上記の他に新たに"デバイスフロー"が追加された


### 2.0 前提

OAuth 2.0の認可付与(Authorization Grant)のそもそもの前提として、クライアントは事前に認可サーバに登録されている必要がある。手順としては、まずクライアントIDとクライアントシークレットを認可サーバから発行してもらい、クライアントはそれを使ってOAuth 2.0のフローを進めていく。逆に言えば、認可サーバは見ず知らずのクライアントは相手にしないし、クライアントも見ず知らずの認可サーバに認可を求めることはない。

**認可サーバに事前に登録されている情報**

|属性|必須|説明|
|:--|:--|:--|
|client_id|yes|クライアントID|
|client_secret|yes|クライアントシークレット|
|redirect_uris|no|指定しなかった場合、認可リクエストのクエリパラメータで指定|

* 上記のほか、認可サーバとリソースサーバとの間で何か必要があれば任意の情報を追加してよい (OAuth 2.0は感知しない)

### 2.1 認可リクエスト

#### (1) 認可リクエスト (クライアントから認可サーバへのリダイレクト)

クライアントはLocationヘッダに以下の属性をQueryStringに設定したURLを指定して302 (Moved Temporary) でレスポンスを返す。

|属性|必須|説明|
|:--|:--|:--|
|response_type|yes|"code" (認可コードフロー) を指定（インプリシットフローは非推奨のため指定可能な値は"code"のみ)|
|scope|no|要求する権限の一覧を空白区切りの文字列で指定|
|client_id|yes|クライアントID|
|redirect_uri|no|認可サーバから戻ってきたときに使用するURL。事前に認可サーバに登録していたときは指定しなくてもよい。*1|
|state|recommended|検証用の属性|
|(new)response_mode|no|認可リクエストに対する認可サーバからの応答の仕方を指定 (query/fragment/form_post)。デフォルトは"query"。*2|

* (*1) redirect_uriが指定された場合、事前に認可サーバに登録したリダイレクトURIと認可リクエストで指定したURIを認可サーバ側でチェックするのが重要(オープンリダイレクトにまつわる脆弱性回避のため)
* (*2) [OAuth & OpenID Connect 関連仕様まとめ](https://bit.ly/3onjuz5) にわかりやすい説明あり。

#### (2) 認可レスポンス (認可サーバからクライアントへのリダイレクト)

認可サーバはリダイレクトされたリクエストを受け取ると、認証や内部でのクライアントIDのチェック等を実行後、問題なければ認可コードを発行し、認可リクエストの`redirect_uri`で指定されたURLにリダイレクトで返す(response_modeが未指定または"query"の場合。"form_post"の場合はredirect_uriへのPOSTを自動実行するHTMLを返す)。認可コードはcodeリクエストパラメータを通じて渡される。

|属性|必須|説明|
|:--|:--|:--|
|code|yes|発行した認可コード|
|state|no|CSRF対策用の属性。リクエストパラメータで指定されていた場合は指定必須。|

### 2.2 アクセストークンリクエスト

#### (1) アクセストークンリクエスト (クライアントから認可サーバへのPOSTメソッド)

クライアントは認証コードを受け取ると、今度は認可サーバに（リダイレクトではなく）直接POSTメソッドでトークン取得のためのリクエストを発行する。その際、Basic認証をおこなうためにAuthorizationヘッダにクライアントIDとクライアントシークレットを設定し、フォーム変数で（認可リクエストで受け取ったばかりの）認可コードを渡す。機密クライアント (Confidential Client) は認証必須。なおクライアント認証はAuthorizationヘッダを使う方法だけでなく、フォーム変数を使う方法もある。公開クライアント(Public Client)の場合は`client_id`だけをPOST変数で送信し、認可サーバはクライアントIDの確認のみでシークレットを使った認証まではしない。

|属性|必須|説明|
|:--|:--|:--|
|Authorizationヘッダ|yes|Basic Base64(<client_id>:<client_secret>)|
|code|yes|認可コード (認可サーバ側で検証用に使用)|
|grant_type|yes|認可コードフローのときは"authorization_code"、トークンリフレッシュ時は"refresh_token'、クライアントクリデンシャルフローのときは"client_credentials"、リソースオーナークリデンシャルフローのときは"password"。|
|client_id|no|Authorizationヘッダでの認証を実行しないときは指定必須|
|redirect_uri|yes|認可リクエスト時にリダイレクトURIを指定していた場合は必須。|

#### (2) アクセストークンレスポンス (認可サーバからクライアントへのレスポンス)

認可サーバはレスポンスボディにJSON形式でアクセストークンとトークンタイプ (たとえばBearerトークンの場合は"Bearer") を返す。

|属性|必須|説明|
|:--|:--|:--|
|token_type|yes|"Bearer"など|
|access_token|yes|アクセストークン|
|expires_in|recommended|期限切れまでの秒数|
|scope|no|スコープ|
|state|no|認可リクエストにstateが含まれていたときは必須|
|refresh_token|no|リフレッシュトークン|

**アクセストークンの例 (RFC6749より)**

```JSON
{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "token_type":"bearer",
  "expires_in":3600,
  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
  "example_parameter":"example_value"
}
```

### 2.3 リソースリクエスト (クライアントからリソースサーバへのリクエスト)

#### (1) リソースリクエスト (クライアントからリソースサーバへのリクエスト)

クライアントはアクセストークンを受け取ると、それを使ってリソースサーバにリソースを要求するリクエストを発行する。アクセストークンを提示する方法はクエリパラメータ、form変数、Authorizationヘッダのどれでもよいが、推奨はAuthorizationヘッダ。

```HTTP
Authorization: Bearer 937ekepsi74l3l23es9
```

#### (2) リソースレスポンス (リソースサーバからクライアントへのレスポンス)

リソースサーバはアクセストークンを検証し、指定された権限に応じてレスポンスを返す。アクセストークン形態は以下のいずれか。

|種類|説明|
|:--|:--|
|認可情報を一意に識別するID| 認可サーバのイントロスペクションエンドポイントを使って認可情報を取得する。認可サーバのDBに直接アクセスできる場合はDBから認可情報を取得してもよい。|
|JWT| JWTに格納された認可情報を解析して使用する|

アクセストークンが無効なものであった場合、`WWW-Authenticate`ヘッダでエラー情報を返す。

### ~~2.4 インプリシットフロー~~

~~クライアントがブラウザアプリケーションの場合に使用する。response_typeに"token"を指定して認可エンドポイントを呼び出すと、認可コードなしで直接アクセストークンが発行される。~~

~~* フロントチャネルだけを使う認可フロー~~
~~* クライアントの認証がない (シークレットが使えないためclient_idの確認のみ) ため、セキュリティ上のリスクがある。~~
~~* リフレッシュトークンが使えない（ただしユーザがその場にいるので必要があれば再度アクセストークンを獲得できる）~~
~~* ブラウザから直接リソースサーバにアクセスするためCORSの有効化が必要~~

### 2.5 クライアントクリデンシャルフロー

リソース所有者が明確に存在しない場合(互いに信頼されたバックエンドシステム同士のやりとりなど)やクライアントアプリケーション自体がリソース所有者であるときに使用する。認可エンドポイントは使わず、直接トークンエンドポイントにgrant_type=client_credentialsを指定してアクセストークンを取得する。

* ブラウザがなく、バックチャネルだけを使うフロー
* 認可コードフローと同様、（通常はAuthorizationヘッダで）クライアント認証をおこなう
* リフレッシュトークンは使われない（いつでもアクセストークンを再取得できるため）

### ~~2.6 パスワードフロー（リソースオーナークリデンシャルフロー）~~

~~クライアントがユーザにユーザIDとパスワードの入力を求め、それをトークンエンドポイントに提示してアクセストークンを取得する（通常はこの方式を使うべきではない。そもそもOAuth 2.0の目的はクライアントにクリデンシャルを知られることなく権限を移譲することなので。ただし、現実的には他の方式が使えず、この方式がもっとも現実的なケースが存在するため仕様に含まれている）。~~

~~* トークンエンドポイントに対し、grant_type=passwordを指定し、さらに`user_name`と`password`をフォーム変数で提示~~

### 2.7 アサーションフロー

クライアントクリデンシャルフローと同様、フロントチャネルがなく直接トークンエンドポイントに対してアクセストークンを要求するフロー。クライアントクリデンシャルフローとの違いは、クライアントクリデンシャルフローの場合はclient_credentialsにクライアントシークレットを指定するのに対し、アサーションフローではアサーション（形式としてはJWTまたはSAMLだが通常はJWT）を指定する点。なお、アサーション自体の入手方法はOAuth 2.0の仕様の範囲外（どのように取得してもよい）。

* grant_typeには`urn:ietf:params:oauth:grant-type:jwt-bearer`を指定する(JWTの場合)
* アサーションは`assertion`フォーム変数として指定する

### 2.8 OAuthフローの選択

以下は『OAuth徹底入門』p.147の「適切な付与方式の選択」から。

```
スタート
　↓
クライアントはリソース　　　　リソース所有者はクライア　　　　クライアントは完全に
所有者の代わりとして　　YES　ント使用中にブラウザで　　YES　ブラウザ内で稼働する　YES　インプリシット
ふるまうのか？　　　　　→　　やりとりを行えるか？　　　　→　　ものか？　　　　　　　→　　フロー
　↓ NO　　　　　　　　　　　　　　↓ NO　　　　　　　　　　　　　　↓ NO
　↓　　　　　　　　　　　　　ユーザはパスワードなど　　　　　認可コードフロー
　↓　　　　　　　　　　　　　単純なクリデンシャルを　　　　　（ネイティブアプリ
　↓　　　　　　　　　　　　　持っているか　　　　　　　　　　のときはPKCEまたは
　↓　　　　　　　　　　　　　　　　↓ YES　　　　　　　　　　　を追加）
　↓　　　　　　　　　　　　　パスワードフロー
クライアントはクライア
ント自身が所有者として　YES　クライアントクリデンシャル
処理をおこなうのか？　　→　　　フロー
　↓ NO
クライアントは信頼できる
サードパーティの許可のもと　YES
で処理をおこなうのか？　　　→　　アサーションフロー
```

### 2.9 ネイティブクライアント

**BCPではネイティブクライアントとSPAも認可コードフロー+PKCEが推奨になっている**

ネイティブクライアントを機密クライアント (Confidential Client: クライアントシークレットを保持するクライアント) として作成すれば、認可コードフローが使える。ただし、認可リクエストとレスポンスを扱うために、ネイティブクライアントはカスタムURLを設定してブラウザを起動し、認可サーバに認可リクエストを送信する必要がある。ユーザ（＝リソース所有者）の認証と認可の許可が完了してリクエストが（リダイレクトとして）戻ってきたとき、カスタムURLを通じてネイティブアプリがコールバックされ、そこで認可サーバのトークンエンドポイントにトークンリクエストを送信する。以降の処理はブラウザクライアントと同じになる。

この場合、ネイティブクライアントが使うブラウザとしては以下の2種類がある。

1. Webビュー
1. システムブラウザ

Webビューはネイティブクライアント内で動作する埋め込みブラウザだが、ネイティブクライアントからユーザのクリデンシャルを盗み見ることが可能なので問題がある。またシステムブラウザとセッションやクッキーを共有しないため、ユーザビリティが落ちるケースがある。なので、こうした問題がないシステムブラウザを使うのがよい。ただし、最近のスマートフォンでは、盗聴不可かつシステムブラウザとセッションやクッキーを共有するものもあるので、それであれば使ってもよい。

ただし、ネイティブクライアントはばらまかれるのでクライアントシークレットを保持するのはセキュリティ上、問題がある。実際には公開クライアントとすべきであり、上記の方法は基本的には使えない。公開クライアントとした場合は、さらに後述するPKCEを使って認可コードフローでアクセストークンを取得する。

公開クライアントの倍、実際には動的クライアント登録も必要なはず。トークンリクエスト時にクライアントシークレットが必要なので。

### 2.10 PKCE

公開クライアントで認可コードフローをより安全に使うために追加された仕様。認可横取り攻撃を防止できる。

#### (1) 認可リクエスト

クライアントはPKCE用に`code_verifier`と呼ばれるシークレットを生成し、保持しておく。これを使って`code_challenge`と呼ばれる値を生成（`code_challenge`は１`code_verifier`そのものか、`code_verifier`のSHA-256ハッシュ）。

|属性|説明|
|:--|:--|
|code_challenge|code_verifierを元に生成したチャレンジ|
|code_challenge_method|チャレンジが平文またはSHA-256のどちらかであるかを示すフラグ|

#### (2) 認可レスポンス

通常の認可コードフローの認可レスポンスと同じ。ただし、認可サーバではリクエストで送信されてきた`code_challenge`と`code_challenge_method`を保存しておく。

#### (2) トークンリクエスト

クライアントは通常のトークンリクエストに必要な属性に加えて、`code_verifier`を追加で送信する。サーバ側はこれを使って認可リクエスト時に受け取ったcode_challengeの値を検証する。

|属性|説明|
|:--|:--|
|code_verifier|PKCE用に追加したシークレット|

### 2.11 トークンイントロスペクション

リソースサーバは受け取ったアクセストークンを認可サーバのトークンイントロスペクションエンドポイントに送信して中身を確認できる。

* 認可サーバは問い合わせてきたリソースサーバを認証する
  * 認証方法はOAuthの仕様の範囲外（通常はクライアントからのトークンリクエストと同様、Basic認証を使うらしい）
  * OiAの実装例では、認可サーバにリソースサーバのIDとシークレットを登録し、これと突き合わせて認証する方法をとっている
* レスポンスはJWTのペイロードによく似たJSON（エンコードはせずJSONをそのまま返す）
  * `active`属性がtrueであればアクセストークンは有効
  * `scope`属性も含む

トークンイントロスペクションは、どのような形態のアクセストークンでも使える。JWTの場合でも、アクセストークンには必要最小限の情報だけ入れておき、トークンイントロスペクションで詳細な情報を取得するような設計にしてもよい。

### 2.12 トークンの取り消し

認可サーバはアクセストークンを無効化できる。ただし、トークンイントロスペクションを使っていない場合、トークンの有効期限が切れるまでは使い続けられてしまう。

一方、クライアントがアクセストークンを無効化したくなるケースもある（リソースサーバとの連携を解除する場合など）。その場合は無効化エンドポイントに対して無効化を要求する。無効化要求のリクエストはアクセストークンリクエストと同様、POST形式かつ認証（通常はBasic認証）をおこなう。

### 2.13 動的登録

ネイティブアプリなど、運用上クライアントを機密クライアントとして構成できないケースでは、動的登録が必要になる。登録方法は以下のとおり。

* 認可サーバの動的登録エンドポイントに動的登録のリクエストを送信する
  * `client_nme`、`redirect_uris`、`client_uri`、`grant_types`、`scope`などを指定したJSONをPOSTで送信
  * `grant_types`には"authorization_code"などを指定
* 認可サーバはリクエスト内容を確認後、クライアントIDとクライアントシークレットを発行＆保存し、その他必要な情報を追加してJSON形式でレスポンスを返す
  * JSONにはリクエスト時に指定されたメタデータすべてのほか、`client_id`、`client_secret`など追加の情報を含む
  * トークンエンドポイントの認証方式を`token_end_point_auth_method`プロパティを通じてクライアントに通知する。"client_secret_basic"が設定されているとクライアントシークレットを使ったBasic認証になる（つまり機密クライアントのときと同じ）。

## 理解の確認のためのテスト

1. クライアントはアクセストークンを受け取るだけで中身はわからない?
  * Yes。認可サーバとリソースサーバは中身を知る必要があるが、それ以外の登場人物はアクセストークンはただのトークン
1. なぜ認可コードが必要なのか？直接アクセストークンを発行すればいいのでは？
  * 直接アクセストークンを発行する方法もある（インプリシットフロー）
  * 認可リクエストはクライアントIDだけしか渡していないのでクライアントを偽装することが容易でセキュアでない
  * リダイレクトによる認可リクエストと、クライアント→認可サーバの直接コールの2つのHTTP接続に分けることで安全性を高めている (仮にトークンリクエストのクライアントシークレットが盗み見られたとしても、別経路で実行された認可リクエストで渡された認可コードがわからないとトークンは取得できない)。
1. リフレッシュトークンはどのように使われるのか?
  * アクセストークン取得時、リフレッシュトークンも取得
  * アクセストークンの期限が切れたら（＝リソースサーバへのアクセスでエラーになったら）、クライアントはリフレッシュトークンを**トークンエンドポイント**（認可エンドポイントではない）にリフレッシュトークンを送信し、新たなアクセストークン（と新たなリフレッシュトークン）を取得する
  * 新たに入手したアクセストークンを使ってリソースサーバにアクセスする
1. クライアントはリソースサーバに対してどのようにアクセストークンを提示するのか？
  * Authorizationヘッダ、form変数、クエリパラメータのいずれか（この順の優先度で方式を選択）
1. Bearerトークン以外のトークンとは何か？

## 実装案

### クライアントと認可サーバ

* 以下のOAuthフローをサポートする (検討中。OIDCの認証と合わせて考える必要あり)
  * 認可コードフロー (+PKCE)・・・Web AppとネイティブApp用
  * アサーションフロー(?)・・・システム連携用
  * リフレッシュトークンはサポートする（自動化を考えると必須）
  * デバイスフローは実装省略 (しばらく使わなさそう)
* サポート機能
  * エンドポイント：認可、トークン、登録、JWK Set Documentエンドポイント？（2.1ではイントロスペクションも推奨。無効化エンドポイントはどうする？）。
  * 動的登録?
  * JWSとJWEは両方サポート必要？
* セキュリティ向上施策
  * クエリーパラメータ経由でアクセストークンを発行する機能は実装しない ... OiA p.200
  * 常にfull https前提
  * リダイレクトは302を使う (307は脆弱性があるので使わない) ... OiA p.213
  * 認可コードフロー + PKCE
  * インプリシットフローとパスワードフロー使用しない (BCPで非推奨)

### リソースサーバ

* Bearerトークンをサポート
  * 3種類の渡し方のうちAuthorizationヘッダとform変数をサポート。
  * クエリパラメータはセキュリティ的に脆弱性になりかねないので実装しない (BCPでも非推奨)

## 参考

1. [OAuth & OIDC 入門編 by #authlete](https://www.youtube.com/watch?v=PKPj_MmLq5E)
1. [The OAuth 2.0 Authorization Framework (RFC6749)](https://tools.ietf.org/html/rfc6749)
1. [OAuth 2.0 Security Best Current Practice (BCP)](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-15#section-2.1.2)
1. [Proof Key for Code Exchange by OAuth Public Clients (PKCE)(RFC7636)](https://tools.ietf.org/html/rfc7636)
1. [OAuth 2.0 for Native Apps (PKCE for mobile)(RFC8252)](https://tools.ietf.org/html/rfc8252)
1. [OAuth 2.0 Device Authorization Grant (RFC8628)](https://tools.ietf.org/html/rfc8628)
1. [アプリで「ログインしっぱなし」はどのように実現されているか？ @Qiita](https://qiita.com/yosshi4486/items/7ec5fdd53577c8663603)
1. [OAuth 2.1 の標準化が進められています](https://qiita.com/flano_yuki/items/bf6ae2eeb5e6447edcc1)
1. [(書籍)OAuth徹底入門 "OAuth 2.0 in Action"の邦訳 (OiA)](https://amzn.to/2GytMez)