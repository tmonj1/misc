## 1. OAuth 2.0の基本的な考え方

OAuthは以下のような問題を解決するために考案された。

* ユーザー(=リソースオーナー)はクライアントからリソースサーバ上の自分のリソースへのアクセスを許可したい
* ただし、クリデンシャルはクライアントに開示したくない
* ユーザがその場にいない状況でもクライアントからリソースサーバにアクセスできるようにしたい
  * 毎回IDとパスワードをユーザが入力するようなことはしたくない

OAuthは上記の問題を、リソースへの初回アクセス時にユーザーの明示的な同意を経て (=いわゆるTOFU: Trusted On First Time)、認可サーバがアクセストークンを発行するという形で解決した。このアクセストークン発行までのフローを定義したものがOAuth 2.0。

クライアントは保護されたリソースへのアクセスが必要になると、ユーザを認可サーバにリダイレクトし、認可コードを持ってきてもらう。その後クライアントは（今度は直接認可サーバにリクエストを実行して）アクセストークンを取得する。これで保護されたリソースにアクセスできるようになる。

ユーザが認可サーバにリダイレクトされたときに認証サーバとユーザとの間で認証が実行されるが、ここの認証方法は何でも良い（OAuth 2.0の仕様の対象外）。また、クライアントはアクセストークンの中身は感知しない。

OAuth 2.0では、セキュリティ上の決定をセキュリティ管理組織側ではなくユーザがおこなうという特徴がある。

## 2. OAuth 2.0 のプロトコル概要

詳細は[RFC6749](https://tools.ietf.org/html/rfc6749)参照するとよい。

OAuth 2.0は大きく分けると**認可リクエスト**と**トークンリクエスト**の2つに分かれている。

|種類|エンドポイント|説明|
|:--|:--|:--|
|認可リクエスト|認可エンドポイント|クライアントから認可サーバへのリダイレクト|
|トークンリクエスト|トークンエンドポイント|クライアントから認可サーバへのリダイレクト|

* 認可リクエスト時、認可サーバはユーザ（＝リソース所有者）を認証する
* トークンリクエスト時、認可サーバはクライアントを認証する

OAuth 2.0の認可フローにはいくつかの種類がある。

|認可フロー|response_type|grant_type|説明|
|:--|:--|:--|:--|
|認可コードフロー|code|authorization_code|最初に認可コードを取得し、次に認可コードをアクセストークンに交換する|
|インプリシットフロー|token|-|認可エンドポイントから直接アクセストークンを発行するフロー|

※ 以降の説明は特に断りが無い限りすべて**認可コードフロー**に基づく

### 2.0 前提

OAuth 2.0の認可付与(Authorization Grant)のそもそもの前提として、クライアントは事前に認可サーバに登録されている必要がある。これは、クライアントIDとクライアントシークレットを認可サーバから発行してもらい、クライアントはそれを使ってOAuth 2.0のフローを進めていく。逆に言えば、認可サーバは見ず知らずのクライアントは相手にしないし、クライアントも見ず知らずの認可サーバに認可を求めることはない。

**認可サーバに事前に登録されている情報**

|属性|必須|説明|
|:--|:--|:--|
|client_id|yes|クライアントID|
|client_secret|yes|クライアントシークレット|
|redirect_uris|no|指定しなかった場合、認可リクエストのクエリパラメータで指定|

* 上記のほか、認可サーバとリソースサーバとの間で何か必要があれば任意の情報を追加してよい (OAuth 2.0は感知しない)

### 2.1 認可リクエスト

#### (1) 認可リクエスト (クライアントから認可サーバへのリダイレクト)

クライアントはLocationヘッダに以下の属性をQueryStringに設定したURLを指定して302 (Moved Temporary) でレスポンスを返す。

|属性|必須|説明|
|:--|:--|:--|
|response_type|yes|認可コードフローのときは"code"、インプリシットフローのときは"token"|
|scope|no|要求する権限の一覧を空白区切りの文字列で指定|
|client_id|yes|クライアントID|
|redirect_uri|no|認可サーバから戻ってきたときに使用するURL。事前に認可サーバに登録していたときは指定しなくてもよい|
|state|recommended|検証用の属性|

#### (2) 認可レスポンス (認可サーバからクライアントへのリダイレクト)

認可サーバはリダイレクトされたリクエストを受け取ると、認証や内部でのクライアントIDのチェック等を実行後、問題なければ認可コードを発行し、認可リクエストの`redirect_uri`で指定されたURLにリダイレクトで返す。認可コードはcodeリクエストパラメータを通じて渡される。

|属性|必須|説明|
|:--|:--|:--|
|code|yes|発行した認可コード|
|state|no|リクエストパラメータで指定されていた場合は指定必須|

### 2.2 アクセストークンリクエスト

#### (1) アクセストークンリクエスト (クライアントから認可サーバへのPOSTメソッド)

クライアントは認証コードを受け取ると、今度は認可サーバに（リダイレクトではなく）直接POSTメソッドでトークン取得のためのリクエストを発行する。その際、Basic認証をおこなうためにAuthorizationヘッダにクライアントIDとクライアントシークレットを設定し、フォーム変数で（認可リクエストで受け取ったばかりの）認可コードを渡す(機密クライアント (Confidential Client) は認証必須。なおクライアント認証はAuthorizationヘッダを使う方法だけでなく、フォーム変数を使う方法もある)。

|属性|必須|説明|
|:--|:--|:--|
|Authorizationヘッダ|yes|Basic Base64(<client_id>:<client_secret>)|
|code|yes|認可コード (認可サーバ側で検証用に使用)|
|grant_type|yes|認可コードフローのときは"authorization_code"、トークンリフレッシュ時は"refresh_token'、クライアントクリデンシャルフローのときは"client_credentials"、リソースオーナークリデンシャルフローのときは"password"。|
|client_id|no|Authorizationヘッダでの認証を実行しないときは指定必須|
|redirect_uri|yes|認可リクエスト時にリダイレクトURIを指定していた場合は必須。|

#### (2) アクセストークンレスポンス (認可サーバからクライアントへのレスポンス)

認可サーバはレスポンスボディにJSON形式でアクセストークンとトークンタイプ (たとえばBearerトークンの場合は"Bearer") を返す。

|属性|必須|説明|
|:--|:--|:--|
|token_type|yes|"Bearer"など|
|access_token|yes|アクセストークン|
|expires_in|recommended|期限切れまでの秒数|
|scope|no|スコープ|
|state|no|認可リクエストにstateが含まれていたときは必須|
|refresh_token|no|リフレッシュトークン|

**アクセストークンの例 (RFC6749より)**

```JSON
{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "token_type":"bearer",
  "expires_in":3600,
  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
  "example_parameter":"example_value"
}
```

### 2.3 リソースリクエスト (クライアントからリソースサーバへのリクエスト)

#### (1) リソースリクエスト (クライアントからリソースサーバへのリクエスト)

クライアントはアクセストークンを受け取ると、それを使ってリソースサーバにリソースを要求するリクエストを発行する。アクセストークンを提示する方法はクエリパラメータ、form変数、Authorizationヘッダのどれでもよいが、推奨はAuthorizationヘッダ。

```HTTP
Authorization: Bearer 937ekepsi74l3l23es9
```

#### (2) リソースレスポンス (リソースサーバからクライアントへのレスポンス)

リソースサーバはアクセストークンを検証し、指定された権限に応じてレスポンスを返す。アクセストークン形態は以下のいずれか。

|種類|説明|
|:--|:--|
|認可情報を一意に識別するID| 認可サーバのイントロスペクションエンドポイントを使って認可情報を取得する。認可サーバのDBに直接アクセスできる場合はDBから認可情報を取得してもよい。|
|JWT| JWTに格納された認可情報を解析して使用する|

### 2.4 インプリシットフロー

クライアントがブラウザアプリケーションの場合に使用する。response_typeに"token"を指定して認可エンドポイントを呼び出すと、認可コードなしで直接アクセストークンが発行される。

* フロントチャネルだけを使う認可フロー
* クライアントの認証がない (シークレットが使えないためclient_idの確認のみ) ため、セキュリティ上のリスクがある。
* リフレッシュトークンが使えない（ただしユーザがその場にいるので必要があれば再度アクセストークンを獲得できる）
* ブラウザから直接リソースサーバにアクセスするためCORSの有効化が必要

### 2.5 クライアントクリデンシャルフロー

リソース所有者が明確に存在しない場合(互いに信頼されたバックエンドシステム同士のやりとりなど)やクライアントアプリケーション自体がリソース所有者であるときに使用する。認可エンドポイントは使わず、直接トークンエンドポイントにgrant_type=client_credentialsを指定してアクセストークンを取得する。

* ブラウザがなく、バックチャネルだけを使うフロー
* 認可コードフローと同様、（通常はAuthorizationヘッダで）クライアント認証をおこなう
* リフレッシュトークンは使われない（いつでもアクセストークンを再取得できるため）

### 2.6 パスワードフロー（リソースオーナークリデンシャルフロー）

クライアントがユーザにユーザIDとパスワードの入力を求め、それをトークンエンドポイントに提示してアクセストークンを取得する（通常はこの方式を使うべきではない。そもそもOAuth 2.0の目的はクライアントにクリデンシャルを知られることなく権限を移譲することなので。ただし、現実的には他の方式が使えず、この方式がもっとも現実的なケースが存在するため仕様に含まれている）。

* トークンエンドポイントに対し、grant_type=passwordを指定し、さらに`user_name`と`password`をフォーム変数で提示

### 2.7 アサーションフロー

クライアントクリデンシャルフローと同様、フロントチャネルがなく直接トークンエンドポイントに対してアクセストークンを要求するフロー。クライアントクリデンシャルフローとの違いは、クライアントクリデンシャルフローの場合はclient_credentialsにクライアントシークレットを指定するのに対し、アサーションフローではアサーション（形式としてはJWTまたはSAMLだが通常はJWT）を指定する点。なお、アサーション自体の入手方法はOAuth 2.0の仕様の範囲外（どのように取得してもよい）。

* grant_typeには`urn:ietf:params:oauth:grant-type:jwt-bearer`を指定する(JWTの場合)
* アサーションは`assertion`フォーム変数として指定する

### 2.8 OAuthフローの選択

以下は『OAuth徹底入門』p.147の「適切な付与方式の選択」から。

```
スタート
　↓
クライアントはリソース　　　　リソース所有者はクライア　　　　クライアントは完全に
所有者の代わりとして　　YES　ント使用中にブラウザで　　YES　ブラウザ内で稼働する　YES　インプリシット
ふるまうのか？　　　　　→　　やりとりを行えるか？　　　　→　　ものか？　　　　　　　→　　フロー
　↓ NO　　　　　　　　　　　　　　↓ NO　　　　　　　　　　　　　　↓ NO
　↓　　　　　　　　　　　　　ユーザはパスワードなど　　　　　認可コードフロー
　↓　　　　　　　　　　　　　単純なクリデンシャルを　　　　　（ネイティブアプリ
　↓　　　　　　　　　　　　　持っているか　　　　　　　　　　のときはPKCEまたは
　↓　　　　　　　　　　　　　　　　↓ YES　　　　　　　　　　　を追加）
　↓　　　　　　　　　　　　　パスワードフロー
クライアントはクライア
ント自身が所有者として　YES　クライアントクリデンシャル
処理をおこなうのか？　　→　　　フロー
　↓ NO
クライアントは信頼できる
サードパーティの許可のもと　YES
で処理をおこなうのか？　　　→　　アサーションフロー
```

## 理解の確認のためのテスト

1. クライアントはアクセストークンを受け取るだけで中身はわからない?
  * Yes。認可サーバとリソースサーバは中身を知る必要があるが、それ以外の登場人物はアクセストークンはただのトークン
1. なぜ認可コードが必要なのか？直接アクセストークンを発行すればいいのでは？
  * 直接アクセストークンを発行する方法もある（インプリシットフロー）
  * 認可リクエストはクライアントIDだけしか渡していないのでクライアントを偽装することが容易でセキュアでない
  * リダイレクトによる認可リクエストと、クライアント→認可サーバの直接コールの2つのHTTP接続に分けることで安全性を高めている (仮にトークンリクエストのクライアントシークレットが盗み見られたとしても、別経路で実行された認可リクエストで渡された認可コードがわからないとトークンは取得できない)。
1. リフレッシュトークンはどのように使われるのか?
  * アクセストークン取得時、リフレッシュトークンも取得
  * アクセストークンの期限が切れたら（＝リソースサーバへのアクセスでエラーになったら）、クライアントはリフレッシュトークンを**トークンエンドポイント**（認可エンドポイントではない）にリフレッシュトークンを送信し、新たなアクセストークン（と新たなリフレッシュトークン）を取得する
  * 新たに入手したアクセストークンを使ってリソースサーバにアクセスする
1. クライアントはリソースサーバに対してどのようにアクセストークンを提示するのか？
  * Authorizationヘッダ、form変数、クエリパラメータのいずれか（この順の優先度で方式を選択）
1. Bearerトークン以外のトークンとは何か？

## 実装案

### クライアントと認可サーバ

* 以下のOAuthフローをサポートする (検討中。OIDCの認証と合わせて考える必要あり)
  * 認可コードフロー (+PKCE)・・・Web AppとネイティブApp用
  * アサーションフロー・・・システム連携用
  * リフレッシュトークンはサポートする（自動化を考えると必須）

### リソースサーバ

* Bearerトークンをサポート (3種類の渡し方(Authorizationヘッダ、form変数、クエリパラメータ)をすべてサポート)

## 参考

1. [OAuth & OIDC 入門編 by #authlete](https://www.youtube.com/watch?v=PKPj_MmLq5E)
1. [The OAuth 2.0 Authorization Framework (RFC6749)](https://tools.ietf.org/html/rfc6749)
1. [アプリで「ログインしっぱなし」はどのように実現されているか？ @Qiita](https://qiita.com/yosshi4486/items/7ec5fdd53577c8663603)